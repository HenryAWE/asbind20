#include <benchmark/benchmark.h>
#include <asbind20/asbind.hpp>
#include <cassert>

// Benchmark for comparing implementing the same logic in different ways:
// a. Pure C++
// b. Pure AS
// c. AS invoking core logic implemented by C++, using native callconv
// d. AS invoking core logic implemented by C++, using generic callconv and asbind20's wrapper
// e. AS invoking core logic implemented by C++, using generic callconv and handwritten wrapper

// 1. Small function returning a+b

namespace bench_fn
{
BENCHMARK_DONT_OPTIMIZE
static int small_fn(int a, int b)
{
    return a + b;
}

template <bool UseGeneric>
static void setup_env(AS_NAMESPACE_QUALIFIER asIScriptEngine* engine)
{
    using namespace asbind20;

    global<UseGeneric>(engine)
        .function("int small_fn(int a,int b)", fp<&small_fn>);
}

static auto prepare_small_fn(AS_NAMESPACE_QUALIFIER asIScriptEngine* engine)
{
    auto* m = engine->GetModule(
        "bench_fn", AS_NAMESPACE_QUALIFIER asGM_ALWAYS_CREATE
    );
    m->AddScriptSection(
        "bench_fn",
        "int run() { return small_fn(1, 2); }"
    );

    [[maybe_unused]]
    int r = m->Build();
    assert(r >= 0);

    auto* f = m->GetFunctionByName("run");
    assert(f != nullptr);

    return asbind20::script_function<int()>(f);
}
} // namespace bench_fn

static void cpp_small_fn(benchmark::State& state)
{
    for(auto&& _ : state)
    {
        BENCHMARK_UNUSED
        int r = bench_fn::small_fn(1, 2);
    }
}

BENCHMARK(cpp_small_fn);

static void script_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    auto engine = make_script_engine();

    auto* m = engine->GetModule(
        "bench_fn", AS_NAMESPACE_QUALIFIER asGM_ALWAYS_CREATE
    );
    m->AddScriptSection(
        "bench_fn",
        "int small_fn(int a, int b) { return a + b; }\n"
        "int run() { return small_fn(1, 2); }"
    );

    [[maybe_unused]]
    int r = m->Build();
    assert(r >= 0);

    script_function<int()> run(m->GetFunctionByName("run"));
    assert(run);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
    }
}

BENCHMARK(script_small_fn);

static void native_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    assert(!has_max_portability());

    auto engine = make_script_engine();
    bench_fn::setup_env<false>(engine);
    auto run = bench_fn::prepare_small_fn(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
    }
}

BENCHMARK(native_small_fn);

static void generic_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    auto engine = make_script_engine();
    bench_fn::setup_env<true>(engine);
    auto run = bench_fn::prepare_small_fn(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
    }
}

BENCHMARK(generic_small_fn);

// Comparing handwritten generic wrapper with the one auto-generated by template
static void handwritten_generic_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    auto engine = make_script_engine();

    AS_NAMESPACE_QUALIFIER asGENFUNC_t gfn = [](AS_NAMESPACE_QUALIFIER asIScriptGeneric* gen)
    {
        int a = gen->GetArgDWord(0);
        int b = gen->GetArgDWord(1);
        int ret = bench_fn::small_fn(a, b);
        gen->SetReturnDWord(ret);
    };
    global<true>(engine)
        .function("int small_fn(int a, int b)", gfn);

    auto run = bench_fn::prepare_small_fn(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
    }
}

BENCHMARK(handwritten_generic_small_fn);

BENCHMARK_MAIN();
