#include "shared_bench_lib.hpp"
#include <asbind20/ext/stdstring.hpp>
#include <cassert>
#include <iostream>

// Benchmark for comparing implementing the same logic in different ways:
// a. Pure C++
// b. Pure AS
// c. AS invoking core logic implemented by C++, using native callconv
// d. AS invoking core logic implemented by C++, using generic callconv and asbind20's wrapper
// e. AS invoking core logic implemented by C++, using generic callconv and handwritten wrapper

// 1. Small function returning a+b

namespace bench_fn
{
static int small_fn(int a, int b)
{
    return a + b;
}

template <bool UseGeneric>
static void setup_small_fn_env(AS_NAMESPACE_QUALIFIER asIScriptEngine* engine)
{
    using namespace asbind20;

    global<UseGeneric>(engine)
        .function("int small_fn(int a,int b)", fp<&small_fn>);
}

static auto prepare_small_fn(AS_NAMESPACE_QUALIFIER asIScriptEngine* engine)
{
    auto* m = engine->GetModule(
        "bench_fn", AS_NAMESPACE_QUALIFIER asGM_ALWAYS_CREATE
    );
    m->AddScriptSection(
        "bench_fn",
        "int run() { return small_fn(1, 2); }"
    );

    [[maybe_unused]]
    int r = m->Build();
    assert(r >= 0);

    auto* f = m->GetFunctionByName("run");
    assert(f != nullptr);

    return asbind20::script_function<int()>(f);
}
} // namespace bench_fn

static void cpp_small_fn(benchmark::State& state)
{
    using asbind_bench::int_identity;
    for(auto&& _ : state)
    {
        int r = bench_fn::small_fn(
            int_identity(1),
            int_identity(2)
        );
        int_identity(r);
    }
}

BENCHMARK(cpp_small_fn);

static void script_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    auto engine = make_script_engine();

    auto* m = engine->GetModule(
        "bench_fn", AS_NAMESPACE_QUALIFIER asGM_ALWAYS_CREATE
    );
    m->AddScriptSection(
        "bench_fn",
        "int small_fn(int a, int b) { return a + b; }\n"
        "int run() { return small_fn(1, 2); }"
    );

    [[maybe_unused]]
    int r = m->Build();
    assert(r >= 0);

    script_function<int()> run(m->GetFunctionByName("run"));
    assert(run);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
        asbind_bench::int_identity(result.value());
    }
}

BENCHMARK(script_small_fn);

static void native_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    assert(!has_max_portability());

    auto engine = make_script_engine();
    bench_fn::setup_small_fn_env<false>(engine);
    auto run = bench_fn::prepare_small_fn(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
        asbind_bench::int_identity(result.value());
    }
}

BENCHMARK(native_small_fn);

static void generic_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    auto engine = make_script_engine();
    bench_fn::setup_small_fn_env<true>(engine);
    auto run = bench_fn::prepare_small_fn(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
        asbind_bench::int_identity(result.value());
    }
}

BENCHMARK(generic_small_fn);

// Comparing handwritten generic wrapper with the one auto-generated by template
static void handwritten_generic_small_fn(benchmark::State& state)
{
    using namespace asbind20;

    auto engine = make_script_engine();

    AS_NAMESPACE_QUALIFIER asGENFUNC_t gfn = [](AS_NAMESPACE_QUALIFIER asIScriptGeneric* gen)
    {
        int a = gen->GetArgDWord(0);
        int b = gen->GetArgDWord(1);
        int ret = bench_fn::small_fn(a, b);
        gen->SetReturnDWord(ret);
    };
    global<true>(engine)
        .function("int small_fn(int a, int b)", gfn);

    auto run = bench_fn::prepare_small_fn(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx);
        assert(result.value() == 3);
        asbind_bench::int_identity(result.value());
    }
}

BENCHMARK(handwritten_generic_small_fn);

namespace bench_fn
{
static std::string str_to_lower(const std::string& str)
{
    std::string result;
    std::transform(
        str.begin(),
        str.end(),
        std::back_inserter(result),
        [](char c) -> char
        {
            if(c >= 'A' && c <= 'Z')
                return c + ('a' - 'A');
            return c;
        }
    );
    return result;
}

template <bool UseGeneric>
static void setup_to_lower_env(AS_NAMESPACE_QUALIFIER asIScriptEngine* engine)
{
    using namespace asbind20;

    ext::register_std_string(engine, true, UseGeneric);
    global<UseGeneric>(engine)
        .function("string to_lower(const string&in)", fp<&str_to_lower>)
        .message_callback(
            +[](const asSMessageInfo* msg)
            { std::cerr << msg->message << std::endl; }
        );
}

static auto prepare_to_lower(AS_NAMESPACE_QUALIFIER asIScriptEngine* engine)
    -> AS_NAMESPACE_QUALIFIER asIScriptFunction*
{
    auto* m = engine->GetModule(
        "bench_to_lower", AS_NAMESPACE_QUALIFIER asGM_ALWAYS_CREATE
    );
    m->AddScriptSection(
        "bench_to_lower",
        "string run(const string&in s1)"
        "{\n"
        "    string str = to_lower(s1);\n"
        "    return str;\n"
        "}"
    );

    BENCHMARK_UNUSED
    int r = m->Build();
    assert(r >= 0);

    // Return the raw script function,
    // because we'll compare the performance for retrieving result from script later
    auto* f = m->GetFunctionByName("run");
    assert(f != nullptr);
    return f;
}

static const std::string to_lower_input_arg = R"(TEST:
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
)";
static const std::string to_lower_input_expected = R"(test:
lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
)";
} // namespace bench_fn

static void native_to_lower_auto_get(benchmark::State& state)
{
    using namespace asbind20;
    using namespace std::string_literals;

    auto engine = make_script_engine();
    bench_fn::setup_to_lower_env<false>(engine);
    script_function<std::string(const std::string&)> run(
        bench_fn::prepare_to_lower(engine)
    );

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        auto result = run(ctx, bench_fn::to_lower_input_arg);
        assert(result.has_value());
        if(result.value() != bench_fn::to_lower_input_expected)
            throw std::runtime_error("bad result=" + result.value());
    }
}

BENCHMARK(native_to_lower_auto_get);

static void native_to_lower_manual_get(benchmark::State& state)
{
    using namespace asbind20;
    using namespace std::string_literals;

    auto engine = make_script_engine();
    bench_fn::setup_to_lower_env<false>(engine);
    auto* f = bench_fn::prepare_to_lower(engine);

    request_context ctx(engine);
    for(auto&& _ : state)
    {
        ctx->Prepare(f);
        set_script_arg(ctx, 0, bench_fn::to_lower_input_arg);

        ctx->Execute();
        BENCHMARK_UNUSED
        int r = ctx->GetState();
        assert(r == AS_NAMESPACE_QUALIFIER asEXECUTION_FINISHED);

        auto* result = static_cast<std::string*>(ctx->GetReturnObject());
        assert(result != nullptr);
        if(*result != bench_fn::to_lower_input_expected)
            throw std::runtime_error("bad result=" + *result);
    }
}

BENCHMARK(native_to_lower_manual_get);

BENCHMARK_MAIN();
